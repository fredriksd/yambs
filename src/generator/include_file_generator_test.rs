use std::fs;

use pretty_assertions::assert_eq;
use tempdir::TempDir;

use super::*;

fn produce_include_path(base_dir: TempDir) -> std::path::PathBuf {
    let build_dir = std::path::PathBuf::from(".build");
    let output_directory = base_dir.path().join(build_dir).join("make_include");
    output_directory
}

fn construct_generator<'generator>(path: &std::path::PathBuf) -> IncludeFileGenerator<'generator> {
    IncludeFileGenerator::new(path, crate::compiler::Compiler::new().unwrap())
}

struct EnvLock {
    mutex: std::sync::Mutex<()>,
    env_var: Option<String>,
    old_env_value: Option<String>,
}

impl EnvLock {
    fn new() -> Self {
        Self {
            mutex: std::sync::Mutex::new(()),
            env_var: None,
            old_env_value: None,
        }
    }
    fn lock(&mut self, env_var: &str, new_value: &str) {
        let _lock = self.mutex.lock().unwrap();
        self.old_env_value = std::env::var(env_var).ok();
        self.env_var = Some(env_var.to_string());
        std::env::set_var(&env_var, new_value);
    }
}

impl Drop for EnvLock {
    fn drop(&mut self) {
        if let Some(ref env_var) = self.env_var {
            if let Some(ref old_env_value) = self.old_env_value {
                std::env::set_var(env_var, old_env_value);
            }
        }
    }
}

#[test]
fn add_cpp_version_cpp98_test() -> Result<(), GeneratorError> {
    let mut lock = EnvLock::new();
    lock.lock("CXX", "gcc");
    let output_directory = produce_include_path(TempDir::new("example").unwrap());
    let mut gen = construct_generator(&output_directory);
    gen.add_cpp_version("c++98");
    assert_eq!(gen.args["C++"], "c++98");
    Ok(())
}

#[test]
fn add_cpp_version_cpp11_test() -> Result<(), GeneratorError> {
    let mut lock = EnvLock::new();
    lock.lock("CXX", "gcc");
    let output_directory = produce_include_path(TempDir::new("example").unwrap());
    let mut gen = construct_generator(&output_directory);
    gen.add_cpp_version("c++11");
    assert_eq!(gen.args["C++"], "c++11");
    Ok(())
}

#[test]
fn add_cpp_version_cpp14_test() -> Result<(), GeneratorError> {
    let output_directory = produce_include_path(TempDir::new("example").unwrap());
    let mut lock = EnvLock::new();
    lock.lock("CXX", "gcc");
    let mut gen = construct_generator(&output_directory);
    gen.add_cpp_version("c++14");
    assert_eq!(gen.args["C++"], "c++14");
    Ok(())
}

#[test]
fn add_cpp_version_cpp17_test() -> Result<(), GeneratorError> {
    let output_directory = produce_include_path(TempDir::new("example").unwrap());
    let mut lock = EnvLock::new();
    lock.lock("CXX", "gcc");
    let mut gen = construct_generator(&output_directory);
    gen.add_cpp_version("c++17");
    assert_eq!(gen.args["C++"], "c++17");
    Ok(())
}

#[test]
fn add_cpp_version_cpp17_uppercase_test() -> Result<(), GeneratorError> {
    let output_directory = produce_include_path(TempDir::new("example").unwrap());
    let mut lock = EnvLock::new();
    lock.lock("CXX", "gcc");
    let mut gen = construct_generator(&output_directory);
    gen.add_cpp_version("C++17");
    assert_eq!(gen.args["C++"], "c++17");
    Ok(())
}

#[test]
fn add_cpp_version_cpp20_test() -> Result<(), GeneratorError> {
    let output_directory = produce_include_path(TempDir::new("example").unwrap());
    let mut lock = EnvLock::new();
    lock.lock("CXX", "gcc");
    let mut gen = construct_generator(&output_directory);
    gen.add_cpp_version("c++20");
    assert_eq!(gen.args["C++"], "c++20");
    Ok(())
}

#[test]
fn generate_strict_mk_test() -> std::io::Result<()> {
    let output_directory = produce_include_path(TempDir::new("example").unwrap());
    let mut gen = construct_generator(&output_directory);
    let file_name = output_directory.join("strict.mk");
    gen.generate_strict_mk().unwrap();
    assert_eq!(format!("\
        #Generated by IncludeFileGenerator.generate_strict_mk. DO NOT EDIT.\n\
        \n\
        include {def_directory}/defines.mk\n\
        \n\
        \n\
        GLINUX_WARNINGS := -Wall \\
                          -Wextra \\
                          -Wshadow \\
                          -Wnon-virtual-dtor \\
                          -Wold-style-cast \\
                          -Wcast-align \\
                          -Wunused \\
                          -Woverloaded-virtual \\
                          -Wpedantic \\
                          -Wconversion \\
                          -Wsign-conversion \\
                          -Wnull-dereference \\
                          -Wdouble-promotion \\
                          -Wformat=2\n\
        \n\
        \n\
        ifeq ($(CXX_USES_GCC), true)
            CXXFLAGS += $(GLINUX_WARNINGS) \\
                        -Wmisleading-indentation \\
                        -Wduplicated-cond \\
                        -Wduplicated-branches \\
                        -Wlogical-op \\
                        -Wuseless-cast\n\
       \n\
       \n\
       else ifeq ($(CXX_USES_CLANG), true)
            CXXFLAGS += $(GLINUX_WARNINGS)\n\
       endif\n\
       \n\
       CXXFLAGS += -std=c++20\n\
        \n\
        \n

        #-Wall                     # Reasonable and standard\n\
        #-Wextra                   # Warn if indentation implies blocks where blocks do not exist.\n\
        #-Wmisleading-indentation  # Warn if if / else chain has duplicated conditions\n\
        #-Wduplicated-cond         # Warn if if / else branches has duplicated conditions\n\
        #-Wduplicated-branches     # warn the user if a variable declaration shadows one from a parent context\n\
        #-Wshadow                  # warn the user if a class with virtual functions has a non-virtual destructor. This helps\n\
        #-Wnon-virtual-dtor        # catch hard to track down memory errors\n\
        #-Wold-style-cast          # warn for C-style casts\n\
        #-Wcast-align              # warn for potential performance problem casts\n\
        #-Wunused                  # warn on anything being unused\n\
        #-Woverloaded-virtual      # warn if you overload (not override) a virtual function\n\
        #-Wpedantic                # warn if non-standard C++ is used\n\
        #-Wconversion              # warn on type conversions that may lose data\n\
        #-Wsign-conversion         # warn on sign conversions\n\
        #-Wnull-dereference        # warn if a null dereference is detected\n\
        #-Wdouble-promotion        # warn if float is implicit promoted to double\n\
        #-Wformat=2                # warn on security issues around functions that format output (ie printf)\n\
        ",
        def_directory = gen.print_build_directory()), fs::read_to_string(file_name.to_str().unwrap()).unwrap());
    Ok(())
}

#[test]
fn generate_debug_mk_test() -> std::io::Result<()> {
    let output_directory = produce_include_path(TempDir::new("example").unwrap());
    let mut gen = construct_generator(&output_directory);
    let file_name = output_directory.join("debug.mk");
    gen.generate_debug_mk().unwrap();
    assert_eq!(
        "\
        #Generated by IncludeFileGenerator.generate_debug_mk. DO NOT EDIT.\n\
        CXXFLAGS += -g \\
                    -O0 \\
                    -gdwarf
        \n\
        \n
        # When building with sanitizer options, certain linker options must be added.\n\
        # For thread sanitizers, -fPIE and -pie will be added to linker and C++ flag options.\n\
        # This is done to support address space layout randomization (ASLR).\n\
        # PIE enables C++ code to be compiled and linked as position-independent code.
        # https://en.wikipedia.org/wiki/Address_space_layout_randomization\n\
        ",
        fs::read_to_string(file_name.to_str().unwrap()).unwrap()
    );
    Ok(())
}

#[test]
fn generate_debug_mk_with_address_sanitizer_test() -> std::io::Result<()> {
    let output_directory = produce_include_path(TempDir::new("example").unwrap());
    let mut gen = construct_generator(&output_directory);
    let file_name = output_directory.join("debug.mk");
    gen.set_sanitizer("address");
    gen.generate_debug_mk().unwrap();
    assert_eq!(
        "\
        #Generated by IncludeFileGenerator.generate_debug_mk. DO NOT EDIT.\n\
        CXXFLAGS += -g \\
                    -O0 \\
                    -gdwarf
        \n\
        CXXFLAGS += -fsanitize=address \n\
        \n\
        LDFLAGS += -fsanitize=address 

        # When building with sanitizer options, certain linker options must be added.\n\
        # For thread sanitizers, -fPIE and -pie will be added to linker and C++ flag options.\n\
        # This is done to support address space layout randomization (ASLR).\n\
        # PIE enables C++ code to be compiled and linked as position-independent code.
        # https://en.wikipedia.org/wiki/Address_space_layout_randomization\n\
        ",
        fs::read_to_string(file_name.to_str().unwrap()).unwrap()
    );
    Ok(())
}

#[test]
fn generate_debug_mk_with_thread_sanitizer_test() -> std::io::Result<()> {
    let output_directory = produce_include_path(TempDir::new("example").unwrap());

    let mut gen = construct_generator(&output_directory);
    let file_name = output_directory.join("debug.mk");
    gen.set_sanitizer("thread");
    gen.generate_debug_mk().unwrap();
    assert_eq!(
        "\
        #Generated by IncludeFileGenerator.generate_debug_mk. DO NOT EDIT.\n\
        CXXFLAGS += -g \\
                    -O0 \\
                    -gdwarf
        \n\
        CXXFLAGS += -fsanitize=thread -fPIE -pie \n\
        \n\
        LDFLAGS += -fsanitize=thread -fPIE -pie 

        # When building with sanitizer options, certain linker options must be added.\n\
        # For thread sanitizers, -fPIE and -pie will be added to linker and C++ flag options.\n\
        # This is done to support address space layout randomization (ASLR).\n\
        # PIE enables C++ code to be compiled and linked as position-independent code.
        # https://en.wikipedia.org/wiki/Address_space_layout_randomization\n\
        ",
        fs::read_to_string(file_name.to_str().unwrap()).unwrap()
    );
    Ok(())
}

#[test]
fn generate_release_mk_test() -> std::io::Result<()> {
    let output_directory = produce_include_path(TempDir::new("example").unwrap());

    let mut gen = construct_generator(&output_directory);
    let file_name = output_directory.join("release.mk");
    gen.generate_release_mk().unwrap();
    assert_eq!(
        "\
        #Generated by IncludeFileGenerator.generate_release_mk. DO NOT EDIT.\n\
        CXXFLAGS += -O3\\
            -DNDEBUG\n
        ",
        fs::read_to_string(file_name.to_str().unwrap()).unwrap()
    );
    Ok(())
}

#[test]
fn generate_default_mk_test() -> std::io::Result<()> {
    let output_directory = produce_include_path(TempDir::new("example").unwrap());
    let mut gen = construct_generator(&output_directory);
    let file_name = output_directory.join("default_make.mk");
    gen.generate_default_mk().unwrap();
    assert_eq!("\
        #Automatic dependency generation: Makes GCC generate the dependencies needed for a cpp file\n\
        #excluding system header files.\n\
        CPPFLAGS+=-MMD\\
            -MP\n
        \n\
        CXXFLAGS+= -pthread", fs::read_to_string(file_name.to_str().unwrap()).unwrap());
    Ok(())
}

#[test]
fn change_directory_test() -> std::io::Result<()> {
    let output_directory = produce_include_path(TempDir::new("example").unwrap());

    let mut gen = construct_generator(&output_directory);

    assert_eq!(gen.output_directory, output_directory);

    let new_output_directory = produce_include_path(TempDir::new("example_new").unwrap());
    gen.change_directory(new_output_directory.clone());

    assert_eq!(gen.output_directory, new_output_directory);
    Ok(())
}

#[test]
fn generate_flags_sanitizer_no_sanitizers_test() -> std::io::Result<()> {
    let output_directory = produce_include_path(TempDir::new("example").unwrap());
    let gen = construct_generator(&output_directory);
    let actual = gen.generate_flags_sanitizer();
    let expected = String::new();
    assert_eq!(expected, actual);
    Ok(())
}

#[test]
fn generate_flags_sanitizer_address_sanitizer_test() -> std::io::Result<()> {
    let output_directory = produce_include_path(TempDir::new("example").unwrap());

    let mut gen = construct_generator(&output_directory);
    gen.set_sanitizer("address");
    let actual = gen.generate_flags_sanitizer();
    let expected = String::from(
        "\
                                    CXXFLAGS += -fsanitize=address \n\
                                    \n\
                                    LDFLAGS += -fsanitize=address ",
    );
    assert_eq!(expected, actual);
    Ok(())
}

#[test]
fn generate_flags_sanitizer_thread_sanitizer_test() -> std::io::Result<()> {
    let output_directory = produce_include_path(TempDir::new("example").unwrap());
    let mut gen = construct_generator(&output_directory);
    gen.set_sanitizer("thread");
    let actual = gen.generate_flags_sanitizer();
    let expected = String::from(
        "\
                                    CXXFLAGS += -fsanitize=thread -fPIE -pie \n\
                                    \n\
                                    LDFLAGS += -fsanitize=thread -fPIE -pie ",
    );
    assert_eq!(expected, actual);
    Ok(())
}

#[test]
fn generate_defines_mk_test() -> std::io::Result<()> {
    let mut lock = EnvLock::new();
    lock.lock("CXX", "gcc");
    let output_directory = produce_include_path(TempDir::new("example").unwrap());
    let mut gen = construct_generator(&output_directory);
    let file_name = output_directory.join("defines.mk");
    gen.generate_defines_mk().unwrap();
    assert_eq!(
        "\
    # Defines.mk\n\
    # Contains a number of defines determined from MyMake configuration time.\n\
    \n\
    CXX_USES_GCC := true\n\
    CXX_USES_CLANG := false\n\
    \n\
    CP := /usr/bin/cp\n\
    CP_FORCE := -f\n\
    \n\
    ",
        fs::read_to_string(file_name.to_str().unwrap()).unwrap()
    );
    Ok(())
}

#[test]
fn evaluate_compiler_with_gcc_results_in_gcc_set() {
    let mut lock = EnvLock::new();
    let output_directory = produce_include_path(TempDir::new("example").unwrap());

    {
        lock.lock("CXX", "gcc");
        let gen = construct_generator(&output_directory);
        assert_eq!(gen.compiler_constants["CXX_USES_GCC"], "true");
        assert_eq!(gen.compiler_constants["CXX_USES_CLANG"], "false");
    }

    {
        lock.lock("CXX", "/usr/bin/gcc");
        let gen = construct_generator(&output_directory);
        assert_eq!(gen.compiler_constants["CXX_USES_GCC"], "true");
        assert_eq!(gen.compiler_constants["CXX_USES_CLANG"], "false");
    }

    {
        lock.lock("CXX", "g++");
        let gen = construct_generator(&output_directory);
        assert_eq!(gen.compiler_constants["CXX_USES_GCC"], "true");
        assert_eq!(gen.compiler_constants["CXX_USES_CLANG"], "false");
    }
    {
        lock.lock("CXX", "/usr/bin/g++");
        let gen = construct_generator(&output_directory);
        assert_eq!(gen.compiler_constants["CXX_USES_GCC"], "true");
        assert_eq!(gen.compiler_constants["CXX_USES_CLANG"], "false");
    }
}

#[test]
fn evaluate_compiler_with_clang_results_in_clang_set() {
    let mut lock = EnvLock::new();
    let output_directory = produce_include_path(TempDir::new("example").unwrap());
    {
        lock.lock("CXX", "clang");
        let gen = construct_generator(&output_directory);
        assert_eq!(gen.compiler_constants["CXX_USES_GCC"], "false");
        assert_eq!(gen.compiler_constants["CXX_USES_CLANG"], "true");
    }
    {
        lock.lock("CXX", "/usr/bin/clang");
        let gen = construct_generator(&output_directory);
        assert_eq!(gen.compiler_constants["CXX_USES_GCC"], "false");
        assert_eq!(gen.compiler_constants["CXX_USES_CLANG"], "true");
    }
}
