
extern crate mmk_parser;

pub mod mmk_generator
{
    use std::fs::File;
    use std::io::Write;
    use mmk_parser::mmk_file_reader;
    pub struct MmkGenerator
    {
        filename: File,
        content: mmk_file_reader::Mmk,
    }
    
    pub trait Generator
    {
        fn new(filename: &str, mmk_content: mmk_file_reader::Mmk ) -> Self;
        fn generate_makefile(self: &mut Self) -> std::io::Result<()>;
        fn generate_header(self: &mut Self) -> std::io::Result<()>;
        fn generate_rule_executable(self: &mut Self) -> std::io::Result<()>;
        fn generate_rule_package(self: &mut Self) -> std::io::Result<()>;
    }

    impl Generator for MmkGenerator
    {
        fn new(filename: &str, mmk_content: mmk_file_reader::Mmk) -> MmkGenerator
        {
            let file = File::create(filename).expect("Something went wrong");
            MmkGenerator{ filename: file, content: mmk_content}
        }

        fn generate_makefile(self: &mut Self) -> std::io::Result<()>
        {
            self.generate_header()?;
            if self.content.data.contains_key("MMK_EXECUTABLE")
            {
                self.generate_rule_executable()?;
            }
            else
            {
                self.generate_rule_package()?;
            }
            Ok(())
        }

        fn generate_header(self: &mut Self) -> std::io::Result<()>
        {
            self.filename.write(b"\
            # Generated by MmkGenerator.generate_header(). DO NOT EDIT THIS FILE.\n\
            \n\
            AR := $(AR.static) # We generate only static static libraries.\n\
            .SUFFIXES:         # We do not use suffixes on makefiles.\n\
            .PHONY: all\n\
            .PHONY: package\n\
            .PHONY: install\n\
            .PHONY: uninstall\n\
            .PHONY: clean\n")?;
            Ok(())
        }


        fn generate_rule_package(self: &mut Self) -> std::io::Result<()>
        {
            let data = format!("\n\
            #Generated by MmkGenerator.generate_rule(). \n\
            .PHONY: {executable}\n\
            {executable}: {sources} \n\
            \t$(strip $(CXX) $(CXXFLAGS) -c $(CPPFLAGS) $^)\n\
            ",
            executable = self.content.to_string("MMK_EXECUTABLE"), 
            sources = self.content.to_string("MMK_SOURCES"));
            
            self.filename.write(data.as_bytes())?;
            Ok(())
        }

        fn generate_rule_executable(self: &mut Self) -> std::io::Result<()>
        {
            let data = format!("\n\
            #Generated by MmkGenerator.generate_rule(). \n\
            .PHONY: {executable}\n\
            {executable}: {sources} \n\
            \t$(strip $(CXX) $(CXXFLAGS) $(CPPFLAGS) $^ -o $@)\n\
            ",
            executable = self.content.to_string("MMK_EXECUTABLE"), 
            sources = self.content.to_string("MMK_SOURCES"));
            
            self.filename.write(data.as_bytes())?;
            Ok(())
        }
    }
}

#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }

    #[test]
    fn test_generate_makefile()
    {
        let mut mmk = super::mmk_parser::mmk_file_reader::Mmk::new();
        mmk.data.insert("MMK_SOURCES".to_string(), vec!["filename.cpp".to_string(), "ofilename.cpp".to_string()]);
        mmk.data.insert("MMK_EXECUTABLE".to_string(), vec!["main".to_string()]);
        let mut gen: super::mmk_generator::MmkGenerator = super::mmk_generator::Generator::new("/home/fredrik/bin/mymake/makefile", mmk);
        assert!(super::mmk_generator::Generator::generate_makefile(&mut gen).is_ok());
    }
}
