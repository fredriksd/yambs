use std::fs::File;
use std::io::Write;
use std::path::PathBuf;
use std::collections::HashMap;

use error::MyMakeError;
use utility;

#[allow(dead_code)]
pub struct IncludeFileGenerator {
    file: Option<File>,
    output_directory: PathBuf,
    args: HashMap<&'static str, String>,
}


#[allow(dead_code)]
impl IncludeFileGenerator {    
    pub fn new(output_directory: &std::path::PathBuf) -> Self {
        utility::create_dir(&output_directory).unwrap();
        IncludeFileGenerator{ file: None, output_directory: output_directory.clone(), args: HashMap::new()}
    }


    fn create_mk_file(&mut self, filename_prefix: &str) {
        let mut filename = PathBuf::from(filename_prefix);
        filename.set_extension("mk");
        let file = utility::create_file(&self.output_directory, filename.to_str().unwrap()).unwrap();
        self.file = Some(file);
    }


    pub fn get_sanitizers(&self) -> String {
        let result = self.args.get("sanitizers");
        if result.is_some() {
            return format!("-fsanitize={}", result.unwrap());
        }
        String::new()
    }


    pub fn set_sanitizers(&mut self, sanitizers: Vec<&str>) {
        let mut sanitizer_str = String::new();
        for option in sanitizers {
            match option {
                "address"   => sanitizer_str.push_str("address "), // sanitizer_str.push_str("address kernel-adress hwaddress pointer-compare pointer-subtract"),
                "thread"    => sanitizer_str.push_str("thread -fPIE -pie "),
                "leak"      => sanitizer_str.push_str("leak "),
                "undefined" => sanitizer_str.push_str("undefined "),
                _           => ()
            }
        }
        // let sanitizer_str = sanitizers.concat();
        self.args.insert("sanitizers", sanitizer_str);
    }


    fn generate_flags_sanitizer(&mut self) -> String {
        if self.args.contains_key("sanitizers") {
            return format!("\
            CXXFLAGS += {sanitizers}\n\
            \n\
            LDFLAGS += {sanitizers}",
            sanitizers = self.get_sanitizers());
        }
        String::new()
    }


    pub fn add_cpp_version(&mut self, version: &str) -> Result<(), MyMakeError> {                
        let cpp_version_string = match version.to_lowercase().as_str() {
            "c++98" => "-std=c++98",
            "c++11" => "-std=c++11",
            "c++14" => "-std=c++14",
            "c++17" => "-std=c++17",
            "c++20" => "-std=c++20",
            _       => return Err(MyMakeError::from(format!("{} is not a valid C++ version.", version)))
        };
        self.args.insert("C++", cpp_version_string.to_string());
        Ok(())
    }


    fn print_cpp_version(&self) -> &str {
        if self.args.contains_key("C++") {
            self.args.get("C++").unwrap()
        }
        else {
            "-std=c++20"
        }
    }


    fn generate_strict_mk(&mut self) -> Result<(), MyMakeError> {
        self.create_mk_file("strict");
        let data = format!("\
        #Generated by IncludeFileGenerator.generate_strict_mk. DO NOT EDIT.\n\

        CXXFLAGS += -Wall \\
                    -Wextra \\
                    -Wmisleading-indentation \\
                    -Wduplicated-cond \\
                    -Wduplicated-branches \\
                    -Wshadow \\
                    -Wnon-virtual-dtor \\
                    -Wold-style-cast \\
                    -Wcast-align \\
                    -Wunused \\
                    -Woverloaded-virtual \\
                    -Wpedantic \\
                    -Wconversion \\
                    -Wsign-conversion \\
                    -Wnull-dereference \\
                    -Wdouble-promotion \\
                    -Wformat=2\n\
       \n\
        CXXFLAGS += {cpp_version}\n\
       \n\
       \n\

        #-Wall                     # Reasonable and standard\n\
        #-Wextra                   # Warn if indentation implies blocks where blocks do not exist.\n\
        #-Wmisleading-indentation  # Warn if if / else chain has duplicated conditions\n\
        #-Wduplicated-cond         # Warn if if / else branches has duplicated conditions\n\
        #-Wduplicated-branches     # warn the user if a variable declaration shadows one from a parent context\n\
        #-Wshadow                  # warn the user if a class with virtual functions has a non-virtual destructor. This helps\n\
        #-Wnon-virtual-dtor        # catch hard to track down memory errors\n\
        #-Wold-style-cast          # warn for C-style casts\n\
        #-Wcast-align              # warn for potential performance problem casts\n\
        #-Wunused                  # warn on anything being unused\n\
        #-Woverloaded-virtual      # warn if you overload (not override) a virtual function\n\
        #-Wpedantic                # warn if non-standard C++ is used\n\
        #-Wconversion              # warn on type conversions that may lose data\n\
        #-Wsign-conversion         # warn on sign conversions\n\
        #-Wnull-dereference        # warn if a null dereference is detected\n\
        #-Wdouble-promotion        # warn if float is implicit promoted to double\n\
        #-Wformat=2                # warn on security issues around functions that format output (ie printf)\n\
        ", 
        cpp_version = self.print_cpp_version());
        match self.file.as_ref().unwrap().write(data.as_bytes()) {
            Ok(_) => (),
            Err(err) => return Err(MyMakeError::from(format!("Error creating strict.mk: {}", err))),
        };
        Ok(())
    }


    fn generate_debug_mk(&mut self) -> Result<(), MyMakeError> {
        self.create_mk_file("debug");
        let data = format!("\
        #Generated by IncludeFileGenerator.generate_debug_mk. DO NOT EDIT.\n\
        CXXFLAGS += -g \\
                    -O0 \\
                    -gdwarf
        \n\
        {flags_sanitizer}\

        # When building with sanitizer options, certain linker options must be added.\n\
        # For thread sanitizers, -fPIE and -pie will be added to linker and C++ flag options.\n\
        # This is done to support address space layout randomization (ASLR).\n\
        # PIE enables C++ code to be compiled and linked as position-independent code.
        # https://en.wikipedia.org/wiki/Address_space_layout_randomization\n\
        ",
        flags_sanitizer = self.generate_flags_sanitizer());
        match self.file.as_ref().unwrap().write(data.as_bytes()) {
            Ok(_) => (),
            Err(err) => return Err(MyMakeError::from(format!("Error creating debug.mk: {}", err))),
        };
        Ok(())
    }


    fn generate_release_mk(&mut self) -> Result<(), MyMakeError> {
        self.create_mk_file("release");
        let data = format!("\
        #Generated by IncludeFileGenerator.generate_release_mk. DO NOT EDIT.\n\
        CXXFLAGS += -O2\\
        ");
        match self.file.as_ref().unwrap().write(data.as_bytes()) {
            Ok(_) => (),
            Err(err) => return Err(MyMakeError::from(format!("Error creating release.mk: {}", err))),
        };
        Ok(())
    }


    fn generate_default_mk(&mut self) -> Result<(), MyMakeError> {
        self.create_mk_file("default_make");
        let data = format!("\
        #Automatic dependency generation: Makes GCC generate the dependencies needed for a cpp file\n\
        #excluding system header files.\n\
        CPPFLAGS+=-MMD\\
            -MP\n
        \n\
        CXXFLAGS+= -pthread");
        match self.file.as_ref().unwrap().write(data.as_bytes()) {
            Ok(_) => (),
            Err(err) => return Err(MyMakeError::from(format!("Error creating release.mk: {}", err))),
        };
        Ok(())
    }


    pub fn generate_makefiles(&mut self) -> Result<(), MyMakeError> {
        self.generate_strict_mk()?;
        self.generate_debug_mk()?;
        self.generate_default_mk()?;
        self.generate_release_mk()
    }


    pub fn print_build_directory(&self) -> &str {
        self.output_directory.to_str().unwrap()
    }


    pub fn change_directory(&mut self, directory: std::path::PathBuf) {
        self.output_directory = directory;
        utility::create_dir(&self.output_directory).unwrap()
    }
}

#[cfg(test)]
#[path = "./include_file_generator_test.rs"]
mod include_file_generator_test;