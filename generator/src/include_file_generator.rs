use std::fs::File;
use std::io::Write;
use std::path::PathBuf;
use std::collections::HashMap;

use error::MyMakeError;

#[allow(dead_code)]
pub struct IncludeFileGenerator {
    file: Option<File>,
    output_directory: PathBuf,
    args: HashMap<&'static str, &'static str>,
}


fn create_dir(dir: &std::path::PathBuf) -> Result<(), MyMakeError> {
    if !dir.is_dir() {
        std::fs::create_dir_all(&dir)?;
    }
    Ok(())
}


fn create_file(dir: &std::path::PathBuf, filename: &str) -> Result<File, MyMakeError> {
    let file = dir.join(filename);
    if file.is_file() {
        match std::fs::remove_file(&file) {
            Ok(()) => (),
            Err(err) => return Err(MyMakeError::from(format!("Error removing {:?}: {}", file, err))),
        };
    }
    let filename = File::create(&file)?;
    Ok(filename)
}


#[allow(dead_code)]
impl IncludeFileGenerator {    
    pub fn new(output_directory: &std::path::PathBuf) -> Self {
        create_dir(&output_directory).unwrap();
        IncludeFileGenerator{ file: None, output_directory: output_directory.clone(), args: HashMap::new()}
    }


    fn create_mk_file(&mut self, filename_prefix: &str) {
        let mut filename = PathBuf::from(filename_prefix);
        filename.set_extension("mk");
        let file = create_file(&self.output_directory, filename.to_str().unwrap()).unwrap();
        self.file = Some(file);
    }


    pub fn add_cpp_version(&mut self, version: &str) -> Result<(), MyMakeError> {                
        let cpp_version_string = match version.to_lowercase().as_str() {
            "c++98" => "-std=c++98",
            "c++11" => "-std=c++11",
            "c++14" => "-std=c++14",
            "c++17" => "-std=c++17",
            "c++20" => "-std=c++20",
            _       => return Err(MyMakeError::from(format!("{} is not a valid C++ version.", version)))
        };
        self.args.insert("C++", cpp_version_string);
        Ok(())
    }


    fn print_cpp_version(&self) -> &str {
        if self.args.contains_key("C++") {
            self.args.get("C++").unwrap()
        }
        else {
            "-std=c++20"
        }
    }


    fn generate_strict_mk(&mut self) -> Result<(), MyMakeError> {
        self.create_mk_file("strict");
        let data = format!("\
        #Generated by IncludeFileGenerator.generate_strict_mk. DO NOT EDIT.\n\

        CXXFLAGS += -Wall \\
                    -Wextra \\
                    -Wmisleading-indentation \\
                    -Wduplicated-cond \\
                    -Wduplicated-branches \\
                    -Wshadow \\
                    -Wnon-virtual-dtor \\
                    -Wold-style-cast \\
                    -Wcast-align \\
                    -Wunused \\
                    -Woverloaded-virtual \\
                    -Wpedantic \\
                    -Wconversion \\
                    -Wsign-conversion \\
                    -Wnull-dereference \\
                    -Wdouble-promotion \\
                    -Wformat=2\n\
       \n\
        CXXFLAGS += {cpp_version}\n\
       \n\
       \n\

        #-Wall                     # Reasonable and standard\n\
        #-Wextra                   # Warn if indentation implies blocks where blocks do not exist.\n\
        #-Wmisleading-indentation  # Warn if if / else chain has duplicated conditions\n\
        #-Wduplicated-cond         # Warn if if / else branches has duplicated conditions\n\
        #-Wduplicated-branches     # warn the user if a variable declaration shadows one from a parent context\n\
        #-Wshadow                  # warn the user if a class with virtual functions has a non-virtual destructor. This helps\n\
        #-Wnon-virtual-dtor        # catch hard to track down memory errors\n\
        #-Wold-style-cast          # warn for C-style casts\n\
        #-Wcast-align              # warn for potential performance problem casts\n\
        #-Wunused                  # warn on anything being unused\n\
        #-Woverloaded-virtual      # warn if you overload (not override) a virtual function\n\
        #-Wpedantic                # warn if non-standard C++ is used\n\
        #-Wconversion              # warn on type conversions that may lose data\n\
        #-Wsign-conversion         # warn on sign conversions\n\
        #-Wnull-dereference        # warn if a null dereference is detected\n\
        #-Wdouble-promotion        # warn if float is implicit promoted to double\n\
        #-Wformat=2                # warn on security issues around functions that format output (ie printf)\n\
        ", 
        cpp_version = self.print_cpp_version());
        match self.file.as_ref().unwrap().write(data.as_bytes()) {
            Ok(_) => (),
            Err(err) => return Err(MyMakeError::from(format!("Error creating strict.mk: {}", err))),
        };
        Ok(())
    }


    fn generate_debug_mk(&mut self) -> Result<(), MyMakeError> {
        self.create_mk_file("debug");
        let data = format!("\
        #Generated by IncludeFileGenerator.generate_debug_mk. DO NOT EDIT.\n\
        CXXFLAGS += -g \\
                    -O0 \\
                    -gdwarf
        ");
        match self.file.as_ref().unwrap().write(data.as_bytes()) {
            Ok(_) => (),
            Err(err) => return Err(MyMakeError::from(format!("Error creating debug.mk: {}", err))),
        };
        Ok(())
    }


    fn generate_release_mk(&mut self) -> Result<(), MyMakeError> {
        self.create_mk_file("release");
        let data = format!("\
        #Generated by IncludeFileGenerator.generate_release_mk. DO NOT EDIT.\n\
        CXXFLAGS += -O2\\
        ");
        match self.file.as_ref().unwrap().write(data.as_bytes()) {
            Ok(_) => (),
            Err(err) => return Err(MyMakeError::from(format!("Error creating release.mk: {}", err))),
        };
        Ok(())
    }


    fn generate_default_mk(&mut self) -> Result<(), MyMakeError> {
        self.create_mk_file("default_make");
        let data = format!("\
        #Automatic dependency generation: Makes GCC generate the dependencies needed for a cpp file\n\
        #excluding system header files.\n\
        CPPFLAGS+=-MMD\\
            -MP\n
        \n\
        CXXFLAGS+= -pthread");
        match self.file.as_ref().unwrap().write(data.as_bytes()) {
            Ok(_) => (),
            Err(err) => return Err(MyMakeError::from(format!("Error creating release.mk: {}", err))),
        };
        Ok(())
    }


    pub fn generate_makefiles(&mut self) -> Result<(), MyMakeError> {
        self.generate_strict_mk()?;
        self.generate_debug_mk()?;
        self.generate_default_mk()?;
        self.generate_release_mk()
    }


    pub fn print_build_directory(&self) -> &str {
        self.output_directory.to_str().unwrap()
    }


    pub fn change_directory(&mut self, directory: std::path::PathBuf) {
        self.output_directory = directory;
        create_dir(&self.output_directory).unwrap()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;
    use tempdir::TempDir;
    use pretty_assertions::assert_eq;

    fn produce_include_path(base_dir: TempDir) -> PathBuf {
        let build_dir = PathBuf::from(".build");
        let output_directory = base_dir.path().join(build_dir).join("make_include");
        output_directory
    }

    #[test]
    fn add_cpp_version_cpp98_test() -> Result<(), MyMakeError> {
        let output_directory = produce_include_path(TempDir::new("example").unwrap());
        let mut gen = IncludeFileGenerator::new(&output_directory);
        gen.add_cpp_version("c++98")?;
        assert_eq!(gen.args["C++"], "-std=c++98");
        Ok(())
    }


    #[test]
    fn add_cpp_version_cpp11_test() -> Result<(), MyMakeError> {
        let output_directory = produce_include_path(TempDir::new("example").unwrap());
        let mut gen = IncludeFileGenerator::new(&output_directory);
        gen.add_cpp_version("c++11")?;
        assert_eq!(gen.args["C++"], "-std=c++11");
        Ok(())
    }


    #[test]
    fn add_cpp_version_cpp14_test() -> Result<(), MyMakeError> {
        let output_directory = produce_include_path(TempDir::new("example").unwrap());
        let mut gen = IncludeFileGenerator::new(&output_directory);
        gen.add_cpp_version("c++14")?;
        assert_eq!(gen.args["C++"], "-std=c++14");
        Ok(())
    }


    #[test]
    fn add_cpp_version_cpp17_test() -> Result<(), MyMakeError> {
        let output_directory = produce_include_path(TempDir::new("example").unwrap());
        let mut gen = IncludeFileGenerator::new(&output_directory);
        gen.add_cpp_version("c++17")?;
        assert_eq!(gen.args["C++"], "-std=c++17");
        Ok(())
    }


    #[test]
    fn add_cpp_version_cpp17_uppercase_test() -> Result<(), MyMakeError> {
        let output_directory = produce_include_path(TempDir::new("example").unwrap());
        let mut gen = IncludeFileGenerator::new(&output_directory);
        gen.add_cpp_version("C++17")?;
        assert_eq!(gen.args["C++"], "-std=c++17");
        Ok(())
    }


    #[test]
    fn add_cpp_version_cpp20_test() -> Result<(), MyMakeError> {
        let output_directory = produce_include_path(TempDir::new("example").unwrap());
        let mut gen = IncludeFileGenerator::new(&output_directory);
        gen.add_cpp_version("c++20")?;
        assert_eq!(gen.args["C++"], "-std=c++20");
        Ok(())
    }


    #[test]
    fn add_cpp_version_invalid_test() -> Result<(), MyMakeError> {
        let output_directory = produce_include_path(TempDir::new("example").unwrap());
        let mut gen = IncludeFileGenerator::new(&output_directory);
        let result = gen.add_cpp_version("python");
        assert!(result.is_err());
        assert_eq!(&String::from("python is not a valid C++ version."), result.unwrap_err().to_string());
        Ok(())
    }


    #[test]
    fn generate_strict_mk_test() -> std::io::Result<()> {
        let output_directory = produce_include_path(TempDir::new("example").unwrap());
        let mut gen = IncludeFileGenerator::new(&output_directory);
        let file_name = output_directory.join("strict.mk");
        gen.generate_strict_mk().unwrap();
        assert_eq!("\
        #Generated by IncludeFileGenerator.generate_strict_mk. DO NOT EDIT.\n\

        CXXFLAGS += -Wall \\
                    -Wextra \\
                    -Wmisleading-indentation \\
                    -Wduplicated-cond \\
                    -Wduplicated-branches \\
                    -Wshadow \\
                    -Wnon-virtual-dtor \\
                    -Wold-style-cast \\
                    -Wcast-align \\
                    -Wunused \\
                    -Woverloaded-virtual \\
                    -Wpedantic \\
                    -Wconversion \\
                    -Wsign-conversion \\
                    -Wnull-dereference \\
                    -Wdouble-promotion \\
                    -Wformat=2\n\
        \n\
        CXXFLAGS += -std=c++20\n\
        \n\
        \n\

        #-Wall                     # Reasonable and standard\n\
        #-Wextra                   # Warn if indentation implies blocks where blocks do not exist.\n\
        #-Wmisleading-indentation  # Warn if if / else chain has duplicated conditions\n\
        #-Wduplicated-cond         # Warn if if / else branches has duplicated conditions\n\
        #-Wduplicated-branches     # warn the user if a variable declaration shadows one from a parent context\n\
        #-Wshadow                  # warn the user if a class with virtual functions has a non-virtual destructor. This helps\n\
        #-Wnon-virtual-dtor        # catch hard to track down memory errors\n\
        #-Wold-style-cast          # warn for C-style casts\n\
        #-Wcast-align              # warn for potential performance problem casts\n\
        #-Wunused                  # warn on anything being unused\n\
        #-Woverloaded-virtual      # warn if you overload (not override) a virtual function\n\
        #-Wpedantic                # warn if non-standard C++ is used\n\
        #-Wconversion              # warn on type conversions that may lose data\n\
        #-Wsign-conversion         # warn on sign conversions\n\
        #-Wnull-dereference        # warn if a null dereference is detected\n\
        #-Wdouble-promotion        # warn if float is implicit promoted to double\n\
        #-Wformat=2                # warn on security issues around functions that format output (ie printf)\n\
        ", fs::read_to_string(file_name.to_str().unwrap()).unwrap());
        Ok(())
    }


    #[test]
    fn generate_debug_mk_test() -> std::io::Result<()> {
        let output_directory = produce_include_path(TempDir::new("example").unwrap());
        let mut gen = IncludeFileGenerator::new(&output_directory);
        let file_name = output_directory.join("debug.mk");
        gen.generate_debug_mk().unwrap();
        assert_eq!("\
        #Generated by IncludeFileGenerator.generate_debug_mk. DO NOT EDIT.\n\
        CXXFLAGS += -g \\
                    -O0 \\
                    -gdwarf
        ", fs::read_to_string(file_name.to_str().unwrap()).unwrap());
        Ok(())
    }


    #[test]
    fn generate_release_mk_test() -> std::io::Result<()> {
        let output_directory = produce_include_path(TempDir::new("example").unwrap());
        let mut gen = IncludeFileGenerator::new(&output_directory);
        let file_name = output_directory.join("release.mk");
        gen.generate_release_mk().unwrap();
        assert_eq!("\
        #Generated by IncludeFileGenerator.generate_release_mk. DO NOT EDIT.\n\
        CXXFLAGS += -O2\\
        ", fs::read_to_string(file_name.to_str().unwrap()).unwrap());
        Ok(())
    }


    #[test]
    fn generate_default_mk_test() -> std::io::Result<()> {
        let output_directory = produce_include_path(TempDir::new("example").unwrap());
        let mut gen = IncludeFileGenerator::new(&output_directory);
        let file_name = output_directory.join("default_make.mk");
        gen.generate_default_mk().unwrap();
        assert_eq!("\
        #Automatic dependency generation: Makes GCC generate the dependencies needed for a cpp file\n\
        #excluding system header files.\n\
        CPPFLAGS+=-MMD\\
            -MP\n
        \n\
        CXXFLAGS+= -pthread", fs::read_to_string(file_name.to_str().unwrap()).unwrap());
        Ok(())
    }


    #[test]
    fn change_directory_test() -> std::io::Result<()> {
        let output_directory = produce_include_path(TempDir::new("example").unwrap());
        let mut gen = IncludeFileGenerator::new(&output_directory);
        
        assert_eq!(gen.output_directory, output_directory);

        let new_output_directory = produce_include_path(TempDir::new("example_new").unwrap());
        gen.change_directory(new_output_directory.clone());

        assert_eq!(gen.output_directory, new_output_directory);
        Ok(())
    }
}